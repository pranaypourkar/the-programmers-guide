# Metrics to Measure

## About

Load testing is not just about sending traffic it’s about **measuring the right system behaviors under stress**. The success of a load test depends heavily on the metrics you capture, how you interpret them, and whether they align with your performance goals.

This section outlines the most important categories of metrics to track during load testing, across system layers and target types.

<table data-header-hidden data-full-width="true"><thead><tr><th width="123.81512451171875"></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>Category</strong></td><td><strong>Metric</strong></td><td><strong>What It Measures</strong></td><td><strong>Why It Matters</strong></td><td><strong>Where It's Relevant</strong></td></tr><tr><td><strong>User-Facing Performance</strong></td><td>Response Time (Avg, P95, Max)</td><td>Time taken to serve a request (including network, processing, DB)</td><td>Indicates latency under load; high percentiles expose tail-end latency and bottlenecks</td><td>API, UI, Backend</td></tr><tr><td></td><td>Throughput (TPS, RPS)</td><td>Requests/transactions processed per second</td><td>Shows system's processing capacity and how it scales</td><td>API, Messaging, Backend</td></tr><tr><td></td><td>Error Rate (%)</td><td>% of failed requests (4xx, 5xx, timeouts, validation errors)</td><td>Affects user experience, SLA compliance, and system correctness</td><td>API, UI, Backend</td></tr><tr><td></td><td>Concurrent Users / Sessions</td><td>Simultaneous users or sessions being handled</td><td>Determines concurrency limits and helps validate user load handling</td><td>All</td></tr><tr><td></td><td>Request Completion Rate</td><td>Total successful vs attempted requests</td><td>Verifies system stability; low completion rate under load may indicate failures or dropped requests</td><td>All</td></tr><tr><td><strong>Infrastructure &#x26; System</strong></td><td>CPU Utilization (%)</td><td>CPU usage per service, container, or node</td><td>High CPU causes thread delays, processing lag, and degraded throughput</td><td>Backend, DB, Load Generator</td></tr><tr><td></td><td>Memory Usage (Heap/Non-Heap)</td><td>RAM used during test; includes garbage-collected memory</td><td>Memory leaks or GC pressure can slow the app or crash it</td><td>Backend, JVM Apps</td></tr><tr><td></td><td>GC Activity (JVM)</td><td>GC frequency, pause duration, memory reclaimed</td><td>Long GC pauses cause latency spikes and request timeout</td><td>JVM-Based Apps</td></tr><tr><td></td><td>Disk I/O</td><td>Read/write latency, IOPS, queue time</td><td>Affects DB performance, logging, and caching behavior</td><td>DB, File-Intensive Apps</td></tr><tr><td></td><td>Network I/O</td><td>Bytes sent/received, latency</td><td>Measures external call impact, CDN load, or backend communication lag</td><td>API, Integrations, Messaging</td></tr><tr><td></td><td>Load Generator Usage</td><td>Resource utilization of load testing tool</td><td>Ensures tool doesn’t become the bottleneck and can handle simulated load</td><td>Load Generator</td></tr><tr><td><strong>Database Behavior</strong></td><td>Query Execution Time</td><td>Average and percentile durations for key queries</td><td>Identifies slow DB operations and poor indexing</td><td>API, Backend, DB</td></tr><tr><td></td><td>Connection Pool Usage</td><td>Active, idle, waiting, and maxed-out connections</td><td>Pool saturation delays backend responses and increases error rates</td><td>Backend, DB</td></tr><tr><td></td><td>Slow Query Count</td><td>Number of queries exceeding performance threshold</td><td>Highlights inefficient or blocking queries</td><td>DB</td></tr><tr><td></td><td>Lock Contention / Deadlocks</td><td>Time spent waiting for locks or number of conflicts</td><td>Indicates concurrency issues or poor transaction design</td><td>DB</td></tr><tr><td></td><td>Transaction Rate</td><td>Total commits/rollbacks per second</td><td>Reveals DB’s processing throughput, especially for write-heavy workflows</td><td>DB</td></tr><tr><td><strong>Application Runtime</strong></td><td>Active Thread Count</td><td>Number of currently executing threads</td><td>Reflects service load; rising threads may indicate pooling issues or blocking I/O</td><td>Backend, Microservices</td></tr><tr><td></td><td>Thread Pool Utilization</td><td>Thread pool in-use vs available threads</td><td>Full pools mean requests queue or time out</td><td>Backend</td></tr><tr><td></td><td>Request Queuing Time</td><td>Time a request waits before being processed</td><td>Helps detect queue saturation and slow backend response</td><td>Async Services, APIs</td></tr><tr><td></td><td>Queue Depth (Messaging)</td><td>Length of processing queues (e.g., Kafka, RabbitMQ)</td><td>Backlogs show consumer underperformance or processing delay</td><td>Messaging, Event-driven Systems</td></tr><tr><td></td><td>Retry / Fallback Counts</td><td>Circuit breaker or retry invocations</td><td>Excessive fallback shows downstream fragility or threshold breaches</td><td>Microservices</td></tr><tr><td><strong>Functional Correctness</strong></td><td>Business Flow Success Rate</td><td>% of transactions that completed the full functional flow</td><td>Validates that core business actions succeed under stress (e.g., order placed, payment complete)</td><td>All</td></tr><tr><td></td><td>Data Integrity Issues</td><td>Duplicate, missing, or corrupted data under concurrency</td><td>Ensures correct handling of concurrent operations and transactions</td><td>DB, Backend</td></tr><tr><td></td><td>Side-Effects Validity</td><td>Were all expected updates, logs, messages created?</td><td>Confirms completeness of side operations like audits, event pushes, etc.</td><td>Backend</td></tr><tr><td><strong>Execution Details</strong></td><td>Test Ramp-up Duration</td><td>Time taken to reach full user load</td><td>Helps observe system behavior as load increases gradually</td><td>All</td></tr><tr><td></td><td>Steady-State Duration</td><td>How long the system was tested under full load</td><td>Important for soak or endurance testing, revealing gradual degradation</td><td>All</td></tr><tr><td></td><td>Requests Sent vs Scheduled</td><td>How many requests were planned vs how many were executed</td><td>Detects tool-side issues or throttling limits on request injection</td><td>All</td></tr><tr><td></td><td>Script / Assertion Failures</td><td>Errors from broken scripts or failed test assertions</td><td>Ensures script validity; separates tool errors from app behavior</td><td>All</td></tr></tbody></table>
