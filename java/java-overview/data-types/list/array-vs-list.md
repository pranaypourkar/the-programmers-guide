# Array vs List



<table data-header-hidden data-full-width="true"><thead><tr><th width="157"></th><th></th><th></th></tr></thead><tbody><tr><td><strong>Aspect</strong></td><td><strong>Array</strong></td><td><strong>List</strong></td></tr><tr><td><strong>Definition</strong></td><td>A fixed-size sequential collection of elements of the same type.</td><td>A resizable and dynamic collection interface, implemented by classes like <code>ArrayList</code>, <code>LinkedList</code>.</td></tr><tr><td><strong>Size</strong></td><td>Fixed size; cannot be resized once created.</td><td>Dynamic size; can grow or shrink as needed.</td></tr><tr><td><strong>Data Type</strong></td><td>Supports both primitives (<code>int</code>, <code>double</code>) and objects (<code>Integer</code>, <code>String</code>).</td><td>Only supports objects (<code>Integer</code>, <code>String</code>), not primitives directly (use wrappers like <code>Integer</code>).</td></tr><tr><td><strong>Indexing</strong></td><td>Indexed-based; supports fast random access with O(1) time complexity.</td><td>Indexed-based (for <code>ArrayList</code>) but slower than arrays for random access (O(1) for <code>ArrayList</code>).</td></tr><tr><td><strong>Memory Allocation</strong></td><td>Contiguous block of memory.</td><td>Depends on implementation (<code>ArrayList</code> uses dynamic arrays, <code>LinkedList</code> uses nodes).</td></tr><tr><td><strong>Flexibility</strong></td><td>Limited; cannot change size, and no utility methods for operations like sorting, searching, etc.</td><td>Highly flexible; provides utility methods (e.g., <code>add</code>, <code>remove</code>, <code>sort</code>) and dynamic resizing.</td></tr><tr><td><strong>Performance</strong></td><td>Better for performance-critical tasks with known, fixed-size data.</td><td>Slower for fixed-size operations due to overhead of dynamic resizing and additional features.</td></tr><tr><td><strong>Ease of Use</strong></td><td>Requires manual resizing or using utility classes (e.g., <code>System.arraycopy</code>) for dynamic behavior.</td><td>Simplified with built-in methods for adding, removing, and manipulating elements.</td></tr><tr><td><strong>Syntactic Complexity</strong></td><td>Can be cumbersome to manage (e.g., resizing, initializing, iterating).</td><td>Easier to use with rich API and utility methods provided by the <code>List</code> interface.</td></tr><tr><td><strong>Null Elements</strong></td><td>Can contain <code>null</code> (for object arrays only).</td><td>Can contain <code>null</code> values (e.g., <code>ArrayList</code>).</td></tr><tr><td><strong>Type Safety</strong></td><td>Type safety is limited (generic arrays cannot be created directly).</td><td>Fully type-safe with generics (e.g., <code>List&#x3C;String></code>).</td></tr><tr><td><strong>Thread Safety</strong></td><td>Not thread-safe by default.</td><td>Not thread-safe (<code>ArrayList</code> is not synchronized, but you can use <code>Collections.synchronizedList</code>).</td></tr><tr><td><strong>Use Case</strong></td><td>Best for situations where size is fixed or performance is critical.</td><td>Best for dynamic collections where size can vary or utility methods are required.</td></tr><tr><td><strong>Iterating</strong></td><td>Requires a <code>for</code> loop or enhanced <code>for-each</code> loop.</td><td>Supports iterators (<code>Iterator</code>, <code>ListIterator</code>), enhanced <code>for-each</code>, and stream operations.</td></tr><tr><td><strong>Sorting</strong></td><td>Manual sorting with custom logic (or using <code>Arrays.sort</code>).</td><td>Built-in sorting with methods like <code>Collections.sort</code>or <code>List.sort</code>.</td></tr><tr><td><strong>Element Type</strong></td><td>Homogeneous elements (same type).</td><td>Homogeneous elements but more flexible with generics.</td></tr><tr><td><strong>Initialization</strong></td><td>Needs explicit size declaration or initialization.</td><td>Easy to initialize dynamically or using utility methods (<code>List.of</code>, <code>Arrays.asList</code>).</td></tr></tbody></table>
